<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Blogs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="from_the_beginning.html">From The Beginning</a></li><li class="chapter-item expanded "><a href="TLS.html"><strong aria-hidden="true">1.</strong> TLS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="racket.html"><strong aria-hidden="true">1.1.</strong> racket</a></li><li class="chapter-item expanded "><a href="cons_and_list.html"><strong aria-hidden="true">1.2.</strong> cons and list</a></li><li class="chapter-item expanded "><a href="stars.html"><strong aria-hidden="true">1.3.</strong> stars</a></li><li class="chapter-item expanded "><a href="shadow.html"><strong aria-hidden="true">1.4.</strong> shadow</a></li><li class="chapter-item expanded "><a href="friends_and_relations.html"><strong aria-hidden="true">1.5.</strong> friends and relations</a></li><li class="chapter-item expanded "><a href="abstract_and_continuation.html"><strong aria-hidden="true">1.6.</strong> continuation</a></li><li class="chapter-item expanded "><a href="halt.html"><strong aria-hidden="true">1.7.</strong> halt</a></li><li class="chapter-item expanded "><a href="y.html"><strong aria-hidden="true">1.8.</strong> y(WIP)</a></li><li class="chapter-item expanded "><a href="type.html"><strong aria-hidden="true">1.9.</strong> type(WIP)</a></li><li class="chapter-item expanded "><a href="lazy.html"><strong aria-hidden="true">1.10.</strong> lazy(WIP)</a></li><li class="chapter-item expanded "><a href="questions_TLS.html"><strong aria-hidden="true">1.11.</strong> questions</a></li></ol></li><li class="chapter-item expanded "><a href="cs144.html"><strong aria-hidden="true">2.</strong> cs144</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="peek.html"><strong aria-hidden="true">2.1.</strong> peek</a></li><li class="chapter-item expanded "><a href="send_and_receive.html"><strong aria-hidden="true">2.2.</strong> send and receive</a></li></ol></li><li class="chapter-item expanded "><a href="fp.html"><strong aria-hidden="true">3.</strong> fp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="不动点组合子与阶乘函数.html"><strong aria-hidden="true">3.1.</strong> 不动点组合子与阶乘函数</a></li></ol></li><li class="chapter-item expanded "><a href="algorithm.html"><strong aria-hidden="true">4.</strong> Algorithm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="minimum_cut_maximum_flow.html"><strong aria-hidden="true">4.1.</strong> minimum cut maximum flow</a></li><li class="chapter-item expanded "><a href="tarjan.html"><strong aria-hidden="true">4.2.</strong> tarjan</a></li><li class="chapter-item expanded "><a href="fft.html"><strong aria-hidden="true">4.3.</strong> fft</a></li></ol></li><li class="chapter-item expanded "><a href="CICD.html"><strong aria-hidden="true">5.</strong> CICD</a></li><li class="chapter-item expanded "><a href="english.html"><strong aria-hidden="true">6.</strong> English</a></li><li class="chapter-item expanded "><a href="伤寒杂病论.html"><strong aria-hidden="true">7.</strong> 伤寒杂病论</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="集中注意力.html"><strong aria-hidden="true">7.1.</strong> 集中注意力</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="test.html">TEST</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Blogs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="stealed-foreword"><a class="header" href="#stealed-foreword">stealed foreword</a></h1>
<blockquote>
<p>The first laboratory session was devoted to finding out that developer feels slippery and that fixer smells awful.</p>
</blockquote>
<h2 id="试试-mdbook"><a class="header" href="#试试-mdbook">试试 <code>mdbook</code></a></h2>
<p><code>github pages</code> 好像静态网页都能托管。</p>
<h2 id="呼呼呼"><a class="header" href="#呼呼呼">呼呼呼</a></h2>
<p>学习，学个屁。真如漏勺兜水，前面学后面忘。</p>
<p>行这逆水行舟之事挫人心志，左看右看不知深处，打道回府舍不得一身长衫，浑浑厄厄竟然不知岁月，转头一看什么也没有留下。</p>
<p>为了学习好吗，对它使用 <code>blog</code> 吧。</p>
<h2 id="哗啦哗啦"><a class="header" href="#哗啦哗啦">哗啦哗啦</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>mdbook</code> 默认的公式是 <code>mathjax</code>。这个 <code>blog</code> 感觉尽量不要把数学的东西丢进来，但等下还是看看 <code>preprocess</code>，把 <code>mathjax</code> 换成 <code>katex</code>，以及</li>
<li><input disabled="" type="checkbox"/>
<code>markdown</code> 看看有没有 <code>CICD</code> 支持的 <code>lint</code>。</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>racket</code> 语法高亮。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="tls"><a class="header" href="#tls">TLS</a></h1>
<blockquote>
<p>One cannot build a beautiful and functional
bridge without a knowledge of steel and dirt and considerable mathematical technique for using
this knowledge to compute the properties of structures.</p>
</blockquote>
<p>开始研习 <em><strong>the little schemer</strong></em>，记录学习过程中的想法</p>
<p>据 preface 所言，此书旨在 <em>teaching reader thinking recursively</em>，为了达成这一目的，作者才选择了 scheme 作为教具。</p>
<p>此书的写作目的并非让读者熟练掌握 scheme 本身，作者明确指出书中只用到了 scheme 的一个小子集。</p>
<p>在 guideline 中，作者建议 <em>Read carefully</em>，并且 <em>Do not read the book in fewer than three sittings</em>。前面章节的理解会影响后面的阅读，请读者保证顺序理解所述内容。</p>
<p>若在读书过程中设立一个明确的目标，大概就是理解并自行推导出 <code>y-combinator</code>，理解其思想。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="racket"><a class="header" href="#racket">Racket</a></h1>
<p><code>racket</code> 是 <code>lisp</code> 的一种方言，是 <code>scheme</code> 的一个 descendant。</p>
<p>没了解过 <code>scheme</code>，不太清楚具体区别。不过据说 <code>racket</code> 能直接用来看 <code>TLS</code>，使用 <code>DrRacket</code>，并选择 <code>racket</code> 原生语言即可：</p>
<pre><code class="language-scheme">#lang racket
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cons-and-list"><a class="header" href="#cons-and-list"><code>cons</code> and <code>list</code></a></h1>
<h2 id="atom"><a class="header" href="#atom"><code>atom</code></a></h2>
<p>序言中定义了 <code>atom?</code>:</p>
<pre><code class="language-scheme">(define atom?
    (lambda (x)
        (and (not (pair? x)) (not (null? x)))))
</code></pre>
<p>即，不是 <code>pair</code>，也不是 <code>null</code> 的东西就叫 <code>atom</code></p>
<pre><code class="language-scheme">&gt; (atom? null)
#f
&gt; (atom? '(1 2 3))
#f

&gt; (atom? #f)
#t
&gt; (atom? 1)
#t
&gt; (atom? &quot;abc&quot;)
#t
</code></pre>
<p>怀疑这是不是书中自造的概念，我在 <code>The Racket Guide</code> 里没看到这个说法</p>
<h2 id="pair-list-和-s-expression"><a class="header" href="#pair-list-和-s-expression"><code>pair</code>, <code>list</code> 和 <code>s-expression</code></a></h2>
<p><em>reference</em> 中提到：</p>
<blockquote>
<p>In general, the result of cons is a pair. The more traditional name for the cons? function is pair?, and we’ll use the traditional name from now on.</p>
</blockquote>
<p>也就是说 <code>cons</code> 是 <code>pair</code> 的构造子，<code>(cons a b)</code> 表示把 <code>a</code> 和 <code>b</code> 连在一起，构成一个 <code>pair</code>。</p>
<blockquote>
<p>这一点与书中不一样。<code>TLS</code> 中并没有 <code>pair</code> 这一回事，而是只有 <code>list</code>，并将 <code>cons</code> 视为 <code>list</code> 的构造子，其第二个参数必须也是一个 <code>list</code>。</p>
<p>我这里还是采用 <code>racket</code> 实际的情况。</p>
<p>对此，书中提到一笔：</p>
<blockquote>
<p><em>In practice, <code>(cons a b)</code> works for all values <code>a</code> and <code>b</code>, and</em></p>
<p><code>(car (cons a b)) = a</code>,
<code>(cdr (cons a b)} = b</code></p>
</blockquote>
</blockquote>
<p>利用 <code>cons</code>，我们构造出 <code>list</code> 和 <code>s-expression</code>，按我理解，二者是递归定义的，以 CFG 写出来大概像这样:</p>
<pre><code class="language-scheme">S-expression = 
    atom |
    list
</code></pre>
<pre><code class="language-scheme">list = 
    null |
    (cons S-expression list)
</code></pre>
<p><code>list</code></p>
<ol>
<li>要么是 <code>null</code></li>
<li>要么是一个特殊的 <code>pair</code>。特殊在于该 <code>pair</code> 的第二个部分一定是一个 <code>list</code>。由此可知，<code>list</code> 必有类似以下的结构：</li>
</ol>
<pre><code class="language-scheme">(cons a (cons b (cons c (cons d null))))
</code></pre>
<p>一个例子是</p>
<pre><code class="language-scheme">&gt; (cons null null)
'(())
</code></pre>
<p><code>racket</code> 中，<code>null</code> 也可以写作 <code>'()</code>。单引号是一个函数 <a href="cons_and_list.html#%60quote%60"><code>quote</code></a> 的简写</p>
<p>值得注意，<code>(cons a b)</code> 直接将 <code>a, b</code> 组成一个 <code>pair</code>，这不等于 <code>(list a b)</code>：</p>
<pre><code class="language-scheme">&gt; (cons 1 2)
'(1 . 2)
&gt; (cons 1 '(2))
'(1 2)
&gt; (list 1 2)
'(1 2)

&gt; (list? (cons 1 2))
#f
&gt; (pair? (cons 1 2))
#t
&gt; (pair? (list 1 2))
# t
</code></pre>
<p><code>'(a b)</code> 表示一个 <code>list</code>，而 <code>'(a . b)</code> 表示一个 <code>pair</code>。应该将前者看作后者的一种简写，<code>'(a b)</code> 写全了应该是 <code>'(a . (b . ()))</code></p>
<h1 id="quote"><a class="header" href="#quote"><code>quote</code></a></h1>
<blockquote>
<p>还需理解 <code>datum</code>。<code>quote</code> 是否与其数据引用有关。</p>
</blockquote>
<pre><code class="language-scheme">'a = (quote a)
'(a b c) = (list 'a 'b 'c)
</code></pre>
<p>在 REPL 里测试一下：</p>
<pre><code class="language-scheme">&gt; '#t
#t
&gt; '1
1
&gt; '&quot;abc&quot;
&quot;abc&quot;

&gt; '()
'()
&gt; (list)
'()
&gt; 'fdasfs
'fdasfs
</code></pre>
<p>一个层层展开的例子：</p>
<pre><code class="language-scheme">''(1)
-&gt; (quote '(1))
-&gt; (quote (quote (list 1)))

&gt; (car ''(1))
'quote
&gt; (cdr ''(1))
'((1))
</code></pre>
<p><strong>分析一下</strong>，首先，要理解 <code>(car ''(1))</code> 得到 <code>'quote</code> ，只需要理解 <code>(quote (quote (list 1)))</code> 是一个 <code>list</code>，它的左侧就是 <code>quote</code></p>
<p>然后为了得到 <code>(cdr ''(1))</code>，这里把 <code>list</code> 看成 <code>pair</code>，即：</p>
<ul>
<li><code>(quote (quote (list 1)))</code> 看作</li>
<li><code>(quote . ((quote (list 1))))</code></li>
</ul>
<p>再例如：</p>
<pre><code class="language-scheme">&gt; (car '(define a 1))
'define
&gt; (car '(+ 1 2))
'+
</code></pre>
<p>这里有个关于 <code>null</code> 的，有点特别的例子：</p>
<pre><code class="language-scheme">&gt; null
'()
&gt; '()
'()
&gt; 'null
'null
&gt; ''()
''()
&gt; ''null
''null
</code></pre>
<h1 id="null"><a class="header" href="#null"><code>null</code></a></h1>
<p>书中指出，<code>(quote ())</code> 是 <code>null</code> 的一种记号。</p>
<blockquote>
<p>Lisp: Also <code>()</code> and <code>'()</code>.</p>
<p>Scheme: Also <code>'()</code></p>
</blockquote>
<p>实验一下:</p>
<pre><code class="language-scheme">&gt; (quote ())
'()
&gt; (null? (quote ()))
#t
</code></pre>
<p>嗯... <code>()</code> 能单独出现在 <code>(quote ())</code> 里，这是否说明解释器以某种规则进行了特判。</p>
<pre><code class="language-scheme">&gt; null
'()
&gt; '()
'()
&gt; (eq? null '())
#t
&gt; (eq? 'null ''())
#f
</code></pre>
<p>有点神秘</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="stars"><a class="header" href="#stars">stars</a></h1>
<p>直到 <code>*-functions</code> 这一章，作者用上了他定义的所有东西。其迭代的对象有</p>
<ol>
<li><code>(cons atom list)</code></li>
<li><code>(cons number list)</code></li>
<li><code>(cons s-expression list)</code></li>
</ol>
<p>从这时起，每次 <code>l</code> 上的迭代都将判断三块地方</p>
<ol>
<li><code>(null? l)</code>，其为边界条件</li>
<li><code>(atom? (car l))</code>，若 <code>#t</code>，则在 <code>(car l)</code> 上递归</li>
<li><code>else</code>，在 <code>(cdr l)</code> 上递归</li>
</ol>
<p>例如 <code>occur*</code></p>
<pre><code class="language-scheme">(define (occur* a l)
  (cond
    ((null? l) 0)
    ((atom? (car l))
     (cond
       ((eq? a (car l)) (add1 (occur* a (cdr l))))
       (else (occur* a (cdr l)))))
    (else (+ (occur* a (car l)) (occur* a (cdr l))))))
</code></pre>
<p>关于 <code>leftmost</code></p>
<pre><code class="language-scheme">(define (leftmost l)
  (cond
    ((null? l) null)
    ((atom? (car l)) (car l))
    (else
     (cond
       ((null? (leftmost (car l)))
        (leftmost (cdr l)))
       (else (leftmost (car l)))))))
</code></pre>
<p>实际上不需要去问 <code>(cdr l)</code>，因为此处左侧要么存在一个 <code>atom</code>，要么为 <code>null</code>，因而只需要考虑 <code>(car l)</code></p>
<pre><code class="language-scheme">(define (leftmost1 l)
  (cond
    ((null? l) null)
    ((atom? (car l)) (car l))
    (else (leftmost1 (car l)))))
</code></pre>
<p>书上给的答案是</p>
<pre><code class="language-scheme">(define (leftmost2 l)
  (cond
    ((atom? (car l)) (car l))
    (else (leftmost2 (car l)))))
</code></pre>
<p>其假设 <code>l</code> 的左侧非 <code>null</code></p>
<p>不清楚实际写代码，如果出了 <code>null</code> 怎么办。是 <code>lisp</code> 不容易出现这种问题吗？</p>
<h2 id="eqlist"><a class="header" href="#eqlist"><code>eqlist?</code></a></h2>
<p>首先，写了一个判断两个 <code>list</code> 是否相等的判定函数 <code>eqlist?</code></p>
<pre><code class="language-scheme">(define (eqlist? l r)
  (cond
    ((and (null? l) (null? r)) #t)
    ((or (null? l) (null? r)) #f)
    (else
     (cond
       ((and (atom? (car l)) (atom? (car r)))
        (and (eq? (car l) (car r))
             (eqlist? (cdr l) (cdr r))))
       ((or (atom? (car l)) (atom? (car r))) #f)
       (else (and (eqlist? (car l) (car r))
                  (eqlist? (cdr l) (cdr r))))))))
</code></pre>
<p>然后，利用这个函数来写一个判定 <code>s-expression</code> 是否相等的函数 <code>equal?</code></p>
<pre><code class="language-scheme">(define (equal l r)
  (cond
    ((and (atom? l) (atom? r)) (eq? l r))
    ((or (atom? l) (atom? r)) #f)
    (else (eqlist? l r))))
</code></pre>
<p>最后，用 <code>equal?</code> 倒回来替换掉 <code>eqlist?</code> 中 <code>s-expression</code> 的比较：</p>
<pre><code class="language-scheme">; modified `eqlist?`
(define (eqlist? l r)
  (cond
    ((and (null? l) (null? r)) #t)
    ((or (null? l) (null? r)) #f)
    (else (and (equal? (car l) (car r))
               (eqlist? (cdr l) (cdr r))))))

; use this `equal?`
(define (equal? l r)
  (cond
    ((and (atom? l) (atom? r)) (eq? l r))
    ((or (atom? l) (atom? r)) #f)
    (else (eqlist? l r))))
</code></pre>
<p>这形成了一个相互递归调用，它的收敛性我不好说</p>
<p>只能勉强看出来，每次调用的过程中，参数都在变，而且应该是作为 <code>list</code> 变短了。这很符合书中所述的某一条 <em>Commandment</em></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow"><a class="header" href="#shadow">shadow</a></h1>
<p>这章没太看懂跟 <code>shadow</code> 有什么关系。</p>
<p>前面写了两个不同形式的算术表达式 <code>parser</code>，后面用另一种方式定义了自然数。</p>
<p>估计是想跟柏拉图的地穴寓言一样表达一下认知论的东西。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="friends-and-relations"><a class="header" href="#friends-and-relations">friends and relations</a></h1>
<h2 id="set"><a class="header" href="#set">set</a></h2>
<p>实现了一些集合操作，没什么好说的</p>
<h2 id="pair"><a class="header" href="#pair">pair</a></h2>
<p>书中的 <code>pair</code> 定义为长为 <code>2</code> 的 <code>list</code>，与实际上不同。</p>
<h2 id="fun"><a class="header" href="#fun">fun</a></h2>
<p>从函数映射的角度看这种...类似 <code>map</code> 的结构</p>
<p>定义 <code>fun?</code> 来判定映射, <code>fullfun?</code> 来判定双射。这不该是满射吗</p>
<p>应该说 <code>map</code> 天然就是满射，所以他这里只判断了单射，于是满射。</p>
<p>这章最后用两种办法判定双射，一种是直接看陪域有没有重复，也就是是不是单射。</p>
<p>问有没有另一种实现，给出的答案是判定其逆映射是不是映射。</p>
<p>嗯...</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="abstract-and-continuation"><a class="header" href="#abstract-and-continuation">abstract and continuation</a></h1>
<p>这章还没深入讲 <code>lambda</code>，只是将其作为抽象工具</p>
<h2 id="continuation"><a class="header" href="#continuation">continuation</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Continuation">Wiki</a>:</p>
<blockquote>
<p>In computer science, a continuation is an abstract representation of the control state of a computer program. A continuation implements (reifies) the program control state, i.e. the continuation is a data structure that represents the computational process at a given point in the process's execution; the created data structure can be accessed by the programming language, instead of being hidden in the runtime environment. Continuations are useful for encoding other control mechanisms in programming languages such as exceptions, generators, coroutines, and so on.</p>
</blockquote>
<p>简单理解的话，感觉是把一个连续过程分解成从节点到节点，并且把节点以具体数据结构表示出来方便后续操作。有点像 <code>linux</code> 的文件系统，有点像流</p>
<h2 id="multiremberco"><a class="header" href="#multiremberco"><code>multirember&amp;co</code></a></h2>
<p>我不好说，这部分有点烧脑</p>
<pre><code class="language-scheme">(define multirember&amp;co
  (lambda (a lat col)
    (cond
      ((null? lat)
       (col '() '()))
      ((eq? a (car lat))
       (multirember&amp;co a (cdr lat)
                       (lambda (newlat seen)
                         (col newlat (cons (car lat) seen)))))
      (else
       (multirember&amp;co a (cdr lat)
                       (lambda (newlat seen)
                         (col (cons (car lat) newlat) seen)))))))
</code></pre>
<p>还是直接来个例子展开：</p>
<pre><code class="language-scheme">(define a-friend
    (lambda (x y) (null? y)))

(multirember&amp;co 2 '(1 2 3) a-friend)

=&gt; (multirember&amp;co 2 '(2 3)
                   (lambda (newlat seen)
                     (a-friend (cons 1 newlat) seen)))

=&gt; (multirember&amp;co 2 '(3)
                   (lambda (newlat' seen')
                     (lambda (newlat seen)
                       (a-friend (cons 1 newlat) seen))
                     newlat'
                     (cons 2 seen')))

=&gt; (multirember&amp;co 2 '()
                   (lambda (newlat'' seen'')
                     (lambda (newlat' seen')
                       (lambda (newlat seen)
                         (a-friend (cons 1 newlat) seen))
                       newlat'
                       (cons 2 seen'))
                     (cons 3 newlat'')
                     seen''))

=&gt; ((lambda (newlat'' seen'')
      (lambda (newlat' seen')
        (lambda (newlat seen)
          (a-friend (cons 1 newlat) seen))
          newlat'
          (cons 2 seen'))
        (cons 3 newlat'')
        seen'')
      '()
      '())

=&gt; ((lambda (newlat' seen')
      (lambda (newlat seen)
        (a-friend (cons 1 newlat) seen))
        newlat'
        (cons 2 seen'))
      (cons 3 '()) 
      '()))

=&gt; ((lambda (newlat seen)
      (a-friend (cons 1 newlat) seen))
    (cons 3 '())
    (cons 2 '()))

=&gt; (a-friend (cons 1 (cons 3 '()) (cons 2 '())))

=&gt; #f
     
</code></pre>
<p>我不好说。</p>
<p>从这个展开来看，该函数会将 <code>l</code> 分成两个 <code>list</code>，前者是去掉 <code>a</code> 的 <code>l</code>，后者是所有的 <code>a</code>。</p>
<p>恕我直言，这个例子举得不是很好。一来这个函数的意义并不显然，二来难度曲线太大，手动模拟起来有些繁琐</p>
<h2 id="已经解包"><a class="header" href="#已经解包">已经解包</a></h2>
<p>我觉得一个简单点的例子也许看的更清楚</p>
<p>写个函数 <code>remove-a&amp;co x l col</code> 处理数字的 <code>list</code>，去掉 <code>l</code> 中的 <code>x</code> 并统计其个数</p>
<pre><code class="language-scheme">(define (remove-a&amp;co x l col)
  (cond
    ((null? l) (col '() 0))
    ((= x (car l))
     (remove-a&amp;co x (cdr l)
                  (lambda (newl cnt)
                    (col newl (add1 cnt)))))
    (else (remove-a&amp;co x (cdr l)
           (lambda (newl cnt)
             (col (cons (car l) newl) cnt))))))

; (remove-a&amp;co 1 '(2 1 3 5 4 1)
;              (lambda (l cnt) (list l cnt)))

; 直接用 `list` 替代这个 `lambda`
(remove-a&amp;co 1 '(2 1 3 5 4 1) list)

; output: 
;   '((2 3 5 4) 2)
</code></pre>
<p>用一个简单点的例子写一下展开过程：</p>
<pre><code class="language-scheme">(remove-a&amp;co 1 '(2 1 3) list)

-&gt;
(remove-a&amp;co 1 '(1 3)
    (lambda (newl cnt)
        (list (cons 2 newl) cnt)))

-&gt;
(remove-a&amp;co 1 '(3)
    (lambda (newl' cnt')
        (lambda (newl cnt)
            (list (cons 2 newl) cnt))
          newl'
          (add1 cnt')))

-&gt;
(remove-a&amp;co 1 '()
    (lambda (newl'' cnt'')
        (lamdba (newl' cnt')
            (lambda (newl cnt)
                (list (cons 2 newl) cnt))
            newl'
            (add1 cnt'))
        (cons 3 newl'')
        cnt''))

-&gt;
((lambda (newl'' cnt'')
    (lamdba (newl' cnt')
        (lambda (newl cnt)
            (list (cons 2 newl) cnt))
        newl'
        (add1 cnt'))
    (cons 3 newl'')
    cnt'')
    '()
    0)

-&gt;
((lambda (newl' cnt')
    (lambda (newl cnt)
        (list (cons 2 newl) cnt))
        newl'
        (add1 cnt'))
    (cons 3 '())
    0)

-&gt;
((lambda (newl cnt)
    (list (cons 2 newl) cnt))
    (cons 3 '())
    1)

-&gt;
(list (cons 2 (cons 3 '())) 1)

; which is
;   '((2 3) 1)
</code></pre>
<p><code>lambda</code> 嵌套 <code>lambda</code>，本该在过程式语言中最里侧的参数，在这里却是从最外侧传进去</p>
<p>数据传递以参数的形式进行，而没有解包的过程</p>
<h2 id="evens-only"><a class="header" href="#evens-only"><code>evens-only*</code></a></h2>
<p>该函数过滤掉 <code>list</code> 中的奇数，并统计去掉奇数的个数。</p>
<p>此习题与之前的差不多，不过要求从 <code>list</code> 的左右两边同时递归，并整合两边递归的结果。</p>
<pre><code class="language-scheme">(define (evens-only*&amp;co l col)
  (cond
    ((null? l) (col '() 0))
    ((atom? (car l))
     (cond
       ((even? (car l))
        (evens-only*&amp;co (cdr l)
                     (lambda (newl cnt)
                       (col (cons (car l) newl) cnt))))
       (else (evens-only*&amp;co (cdr l)
                          (lambda (newl cnt)
                            (col newl (add1 cnt)))))))
    (else (evens-only*&amp;co (cdr l)
                       (lambda (newld cntd)
                         (evens-only*&amp;co (car l)
                                         (lambda (newla cnta)
                                           (col (cons newla newld)
                                                (+ cnta cntd)))))))))

(evens-only*&amp;co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) list)

; '(((2 8) 10 (() 6) 2) 6)
</code></pre>
<p>这个整合两侧的 <code>lambda</code> 很不好想。</p>
<p>之所以能写出这个 <code>collector</code>，我想是因为二叉树可以拉直成一条链</p>
<p>从回调函数的角度来理解，当 <code>(lambda (newl cnt) ...)</code> 定义出来时，就该假设其函数体定义里已经得到了 <code>newl, cnt</code> 的值，并且能够自由使用</p>
<p>嗯...</p>
<p><code>callback</code> 可能是个不错的角度</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="halt"><a class="header" href="#halt">halt</a></h1>
<blockquote>
<p>A's arguments, like shuffie's and looking's, do not necessarily decrease for the recursion.</p>
</blockquote>
<p>第九章从几个函数出发简单介绍了一下停机和死循环。</p>
<p>它将最终会停机的函数称为 <code>total</code>，否则称为 <code>partial</code>。</p>
<p>以映射角度看函数，其居然有值无法到达陪域，因而称为 <code>partial function</code></p>
<h2 id="停机"><a class="header" href="#停机">停机</a></h2>
<p>这里给的证明是若函数 <code>will-stop?</code> 是 <code>total</code> 的，则：</p>
<pre><code class="language-scheme">(will-stop? (lambda (x)
    (and (will-stop? last-try)
        (eternity x))))
</code></pre>
<p>会得到矛盾的值。</p>
<p>《计算理论导引》那书上的停机问题好像是归约到图灵机 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">TM</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 不可判定上去</p>
<h2 id="λ-递归"><a class="header" href="#λ-递归"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 递归</a></h2>
<pre><code class="language-scheme">(lambda (x) (x x))
</code></pre>
<p>这个例子相当引人入胜，用 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 构造出 <code>length</code> 来计算 <code>list</code> 的长度：</p>
<h3 id="尝试"><a class="header" href="#尝试">尝试</a></h3>
<pre><code class="language-scheme">(((lambda (mk-length)
   (mk-length mk-length))
 (lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1
              (length (cdr l)))))))) 
 '())
</code></pre>
<p>这个仅能计算一层，展开的话是：</p>
<pre><code class="language-scheme">-&gt;
(((lambda (length)
  (lambda (l)
    (cond
      ((null? l) 0)
      (else (add1
            (length (cdr l)))))))
  (lambda (length)
    (lambda (l)
      (cond
      ((null? l) 0)
       (else (add1
             (length (cdr l))))))))
  '())

-&gt;
((lambda (l)
    (cond
    ((null? l) 0)
    (else (add1
        ((lambda (length)
           (lambda (l)
            (cond
              ((null? l) 0)
              (else (add1
                (length (cdr l)))))))
           (cdr l))))))                 ; 本应传递一个 `length` 得到内部的 lambda，但传递了一个 `list`
  '())

-&gt;
0
</code></pre>
<p>可以看出来尚不足以进行长度大于 <code>0</code> 的递归，因为到后面 <code>length</code> 没有正确的参数传进去。</p>
<h3 id="修复"><a class="header" href="#修复">修复</a></h3>
<pre><code class="language-scheme">; 一步步改进
(((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1
              ((mk-length eternity)
               (cdr l))))))))
 '(1))
</code></pre>
<p>这里放了个 <code>eternity</code> 虚位以待，然而并不能改变它算不了非空 <code>list</code> 的事实：</p>
<pre><code class="language-scheme">-&gt;
(lambda (l)
  (cond
  ((null? l) 0)
  (else (add1
    ((lambda (mk-length)
      (lambda (l)
        (cond
          ((null? l) 0)
          (else (add1 
                  (mk-length (cdr l)))))))
      eternity                      ; 充其量
      (cdr l))))))

-&gt;
(lambda (l)
  (cond
    ((null? l) 0)
    (else (add1
      ((lambda (l')
          (cond
            ((null? l') 0)
            (else (add1 
                    (eternity (cdr l))))))
        (cdr l))))))
</code></pre>
<p>可以看出仅能递归两层。</p>
<p>接下来的任务是要用一个无穷递归来替换 <code>eternity</code></p>
<h3 id="无穷"><a class="header" href="#无穷">无穷</a></h3>
<p>为了让递归更明显，多写几层，无穷递归部分仍以 <code>eternity</code> 暂时代替</p>
<pre><code class="language-scheme">(lambda (l)
(cond
((null? l) 0)
(else (add1
  (
    (lambda (l)
    (cond
    ((null? l) 0)
    (else (add1
      (
        (lambda (l)
        (cond
        ((null? l) 0)
        (else (add1
          (
            (lambda (l)
            (cond
            ((null? l) 0)
            (else (add1
              (
                (lambda (l)
                (cond
                ((null? l) 0)
                (else (add1
                  (
                    (lambda (l)
                    (cond
                    ((null? l) 0)
                    (else (add1
                      (
                        (lambda (l)
                        (cond
                        ((null? l) 0)
                        (else (add1
                          (
                            (lambda (l)
                            (cond
                            ((null? l) 0)
                            (else (add1
                              (
                                (lambda (l)
                                (cond
                                ((null? l) 0)
                                (else (add1
                                  (
                                    (lambda (l)
                                    (cond
                                    ((null? l) 0)
                                    (else (add1
                                      (
                                        (lambda (l)
                                        (cond
                                        ((null? l) 0)
                                        (else (add1
                                          (
                                            (lambda (l)
                                            (cond
                                            ((null? l) 0)
                                            (else (add1
                                              (
                                                eternity
                                            (cdr l))))))
                                        (cdr l))))))
                                    (cdr l))))))
                                (cdr l))))))
                            (cdr l))))))
                        (cdr l))))))
                    (cdr l))))))
                (cdr l))))))
            (cdr l))))))
        (cdr l))))))
    (cdr l))))))
(cdr l))))))
</code></pre>
<p>回过头看用 <code>eternity</code> 作为占位符的定义：</p>
<pre><code class="language-scheme">((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1
              ((mk-length eternity)
               (cdr l))))))))
</code></pre>
<p>最后真正想要得到的是这一部分：</p>
<pre><code class="language-scheme">(lambda (l)
  (cond
    ((null? l) 0)
    (else (add1
            ((mk-length eternity)
             (cdr l))))))
</code></pre>
<p>并且想要用这一个整体自身来替换 <code>(mk-length eternity)</code></p>
<pre><code class="language-scheme">(lambda (l)
  (cond
    ((null? l) 0)
    (else (add1
            ((lambda (l)
              (cond
                ((null? l) 0)
                (else (add1
                        ((mk-length eternity)
                        (cdr l)))))))
             (cdr l))))))
</code></pre>
<p>换言之，我需要找到一个 <code>eternity</code> 满足</p>
<pre><code class="language-scheme">
(mk-length eternity) 

=

(lambda (l)
  (cond
    ((null? l) 0)
    (else (add1
            ((mk-length eternity)
             (cdr l))))))

</code></pre>
<p>然而答案一开始就给出来了：</p>
<pre><code class="language-scheme">mk-length = 
(lambda (mk-length)
  (lambda (l)
    (cond
      ((null? l) 0)
      (else (add1
              ((mk-length eternity)
              (cdr l))))))))

(mk-length mk-length) = 
(lambda (l)
  (cond
    ((null? l) 0)
    (else (add1
            ((mk-length eternity)
            (cdr l))))))))
</code></pre>
<p>于是只需要取 <code>eternity</code> 在这里等于 <code>mk-length</code> 即可</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ywip"><a class="header" href="#ywip">y(WIP)</a></h1>
<p><code>TLS</code> 里最终抽象出来的 <code>Y</code> 组合子长这样：</p>
<pre><code class="language-scheme">(define Y
    (lambda (le)
        ((lambda (f) (f f))
         (lambda (f) 
            (le (lambda (x) ((f f) x)))))))
</code></pre>
<p>里边稍微 <code>apply</code> 一层就跟经典的长得一样了：</p>
<pre><code class="language-scheme">(define Y
    (lambda (le)
        ((lambda (f)
            (le (lambda (x) ((f f) x))))
         (lambda (f)
            (le (lambda (x) ((f f) x)))))))
</code></pre>
<p>注意 <code>(lambda (x) ((f f) x))</code> 其实就是 <code>(f f)</code>，这里为了惰性求值包了一层。</p>
<pre><code class="language-scheme">(define Y
    (lambda (le)
        ((lambda (f)
            (le (f f)))
         (lambda (f)
            (le (f f))))))

(define fact
  (Y (lambda (fact1)
       (lambda (n)
         (cond
           ((= n 1) 1)
           (else (* n (fact1 (sub1 n)))))))))

(fact 1)
(fact 2)
(fact 3)
(fact 5)
</code></pre>
<p>上述写法会无穷递归</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="typewip"><a class="header" href="#typewip">type(WIP)</a></h1>
<p>找找有没有办法查看表达式的类型。</p>
<p>或者说有没有官方支持的类型。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="lazywip"><a class="header" href="#lazywip">lazy(WIP)</a></h1>
<p>在提取 <code>length</code> 里面 <code>(mk-length mk-length)</code> 的时候，利用 <code>lambda</code> 包一层实现了惰性，问：</p>
<pre><code class="language-scheme">(a a)

(lambda (x)
    ((a a) x))
</code></pre>
<p>有什么区别</p>
<p>在正常求值的时候应该看不出来区别，然而在作为参数传递的时候区别很大：</p>
<pre><code class="language-scheme">(define (do-x f x)
    (f x))

(do-x (a a) 1)
；先求值 (a a)，再代入

(do-x (lambda (x)
        ((a a) x)) 1)
-&gt;
((lambda (x) ((a a) x)) 1)
-&gt;
((a a) 1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="questions"><a class="header" href="#questions">questions</a></h1>
<h2 id="1-explain"><a class="header" href="#1-explain">1. explain</a></h2>
<pre><code class="language-scheme">&gt; null
'()
&gt; '()
'()
&gt; (eq? null '())
#t
&gt; (eq? 'null ''())
#f
</code></pre>
<h2 id="2-why-not-same"><a class="header" href="#2-why-not-same">2. why not same</a></h2>
<pre><code class="language-scheme">&gt; (eq? (quote 1) 1)
#t
&gt; (eq? (quote a) a)
#f
&gt; a
'()
&gt; (define y a)
&gt; (eq? (quote a) y)
#f
</code></pre>
<h2 id="3-litteral"><a class="header" href="#3-litteral">3. litteral?</a></h2>
<p>能否写一个函数 <code>car l</code>，使其返回 <code>l</code> 的第一个字符？</p>
<p>不同于 <code>car '(+ 2 3)</code> 会得到 <code>'+</code>，能否有 <code>car1 (+ 2 3)</code> 得到 <code>'+</code>？</p>
<p>感觉不行，默认是按值传递的。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cs144"><a class="header" href="#cs144">cs144</a></h1>
<p>体验，学习，顺便考研</p>
<h2 id="spring-2023"><a class="header" href="#spring-2023">Spring 2023</a></h2>
<p><a href="https://cs144.github.io/">官网</a></p>
<p>每年都用一个 <code>url</code>，不知道将来还能不能找到这一年的存档</p>
<h2 id="我的作业-repo"><a class="header" href="#我的作业-repo">我的作业 repo</a></h2>
<p><a href="https://github.com/Tramis/cs144_rust"><img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub" /></a></p>
<h2 id="rust"><a class="header" href="#rust">rust</a></h2>
<p>本来是想用 <code>rust</code> 做的，课程要求的 <code>cpp</code> 风格很严格，不能有 <code>new/delete</code>，不能有裸指针，要积极加 <code>const qualifier</code>，不能 <code>c</code> 风格 <code>cast</code>，感觉不如直接用 <code>rust</code></p>
<p>但底层代码以及，尤其是大量的测试代码，都是内嵌 <code>cpp</code>，一时让人不太想重写</p>
<p>还是先用 <code>cpp</code> 做完一遍再看看自己实现吧</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="peek"><a class="header" href="#peek">peek</a></h1>
<p>lab0 的第一部分是模仿 <code>telnet</code> 的操作，用它给的 <code>socket</code> 实现去进行一个 <code>http</code> 的 <code>GET</code> 请求</p>
<p><img src="img/socket.svg" alt="socket read and write" /></p>
<p>每个 <code>socket</code> 都在 <code>write</code> 对面和 <code>read</code> 自己，这与后面实现的 <code>StreamBytes</code> 类不同</p>
<h2 id="bytestream"><a class="header" href="#bytestream"><code>ByteStream</code></a></h2>
<p>第二部分</p>
<p>按照要求，这是一个单线程读写 <code>Stream</code></p>
<p>也就是说，同时只有一个 <code>writer</code> 和一个 <code>reader</code>，而且 <code>reader</code> 读的还都是这个 <code>writer</code> 写的东西</p>
<p>这部分的主要问题在于 <code>peek</code> 函数</p>
<pre><code class="language-cpp">class Reader : public ByteStream
{
public:
  std::string_view peek() const; // Peek at the next bytes in the buffer
</code></pre>
<p>函数是 <code>const</code> 的，说明没有副作用</p>
<p>返回值类型是 <code>string_view</code>，这是一个引用，相当于 <code>slice</code></p>
<p>这说明该函数应该返回自己内部数据的一个引用类型</p>
<p>然而 <code>string_view</code> 要求引用的数据是 <code>contiguous</code> 的，也就是说在内存里要挨着</p>
<p>如果我来定义这个 <code>peek</code> 我估计会返回一个迭代器</p>
<p>总之这样就只能用 <code>vector</code> 了，并且用它模拟一个环</p>
<p>然而新问题在于 <code>peek</code> 需要能返回多长的内容</p>
<p>如果返回迭代器就没有这个问题，但返回 <code>string_view</code> 代表返回的内容长度需要我来决定</p>
<p>额</p>
<p>既然用 <code>vector</code> 模拟环了，那么能返回的长度上限就不是 <code>capacity</code>，而是从 <code>head</code> 到 <code>vector.end()</code> 之间，这样会导致 <code>peek</code> 不能保证 <code>peek</code> 到全部内容</p>
<p>...</p>
<p>然而这么写的话，测试都过了</p>
<p>不好说</p>
<p>在不 <code>pop</code> 的情况下，明显会出现有一部分内容永远无法 <code>peek</code> 到的情况</p>
<p><img src="img/byte_stream.svg" alt="ByteStream" /></p>
<p>这应该不是一个好的定义</p>
<h2 id="vector-模拟环"><a class="header" href="#vector-模拟环"><code>vector</code> 模拟环</a></h2>
<p>我计算下标的时候直接储存了单调递增的 <code>head</code> 和 <code>tail</code>，虽然是 <code>uint64</code> 类型，但终究是有限数</p>
<p>...</p>
<p>不好说，感觉问题很大</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="send-and-receive"><a class="header" href="#send-and-receive">send and receive</a></h1>
<p>此时才意识到这个 cs144 的 lab 其实没有那么底层，它的 send 实现甚至是让人填空 <code>maybe_send()</code>，然后外部轮询</p>
<p>有点琐碎，细枝末节太多，感觉一个月后什么也不记得。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="fp"><a class="header" href="#fp">fp</a></h1>
<blockquote>
<p>But what about creative composition? In order to be creative one must first gain control of the medium. One can not even begin to think about organizing a great photograph without having the skills to make it happen. In engineering, as in other creative arts, we must learn to do analysis to support our efforts in synthesis. One cannot build a beautiful and functional bridge without a knowledge of steel and dirt and considerable mathematical technique for using this knowledge to compute the properties of structures. Similarly, one cannot build a beautiful computer system without a deep understanding of how to &quot;previsualize&quot; the process generated by the procedures one writes.</p>
</blockquote>
<p>当真不论哪个分叉都洋洋兮若江河，看不见顶摸不着底。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="又是-lambda-wip"><a class="header" href="#又是-lambda-wip">又是 lambda (WIP)</a></h1>
<p>时隔良久，又忙里偷闲捡起来这东西。</p>
<p>看了<a href="https://thzt.github.io/2017/03/14/recursive-function-7/">这个博客</a>，感觉是很好的补充，又把没理解的东西捡起来试图理解一下。（也是在翻了这作者的博文之后，让我起了好好记录 <code>blog</code> 的念头。</p>
<h2 id="解方程"><a class="header" href="#解方程">解方程</a></h2>
<p>对于阶乘函数 <code>fact</code></p>
<pre><code class="language-haskell">fact :: Int -&gt; Int
fact n = case n of 
  1 -&gt; 1
  n -&gt; n * fact (n-1)
</code></pre>
<p>有一个问题是如何只用 lambda 演算来实现 <code>fact</code>。具体一点来说，需要在 <code>fact</code> 内部不能调用 <code>fact</code>  自身。</p>
<p>一定程度上来说，这个要求是很直观的，因为在函数内部调用 <code>fact</code> 时，<code>fact</code> 自身还没定义完，怎么能够调用它呢？</p>
<p>在上面提到的博文当中，该文作者视函数定义为一个方程（可能也确实是），<code>fact n</code> 后的等号 <code>=</code>，就是数学意义上的等号，等号两侧完全等价。</p>
<p>如果能够利用这个方程，直接解出 <code>fact</code> 的定义，那么也就得到了 <code>fact</code> 的定义，绕过了先有鸡还是先有蛋的问题。</p>
<h2 id="不动点"><a class="header" href="#不动点">不动点</a></h2>
<p>中学数学里其实很直接少见到递归的概念，偶尔出现也只是出于数列题目，浮光掠影。</p>
<p>然而哪怕只是很少出现，也有人已经把不动点的概念引入到各种高中教辅书里，配上标题：『不动点法求通项公式』，配图往往有两种，一种是一个螺旋状，另一种是折线。（折线的大概长这样）：</p>
<pre><code class="language-ascii">       ▲
       │
       │
       │
       │
       │                                                 xx
       │                                                xx               lll
       │                                              xx         lllllllll
       │                                           xxx     llllll
       │                                        xxx lllllll
       │                                     llllllll
       │                               lll▲─►l
       │                         lllll┌───┘x
       │                     lllll    ▲xxx
       │                 lll┌────────►┘x
       │             lllll  ▲      xxx
       │         lllll      │    xx
       │     lllll          │  xx
       lllllll▲─────────────►xx
lllllll│      │            xx
l      │      │         xxx
       │      │       xxx
       │      │     xxx
       │      │    xx         y=x
       │      │  xx
       │      │xx
       │     x│x
       │    xx│
       │  xx  │
───────┘xx────┴───────────────────────────────────────────────────────────────►
      xx
    xx │
   x   │
 xx    │
</code></pre>
<p>基本意思就是不动点随着数列趋于极限，将逐步收敛到一个“稳定”的定值。或者干脆就等于这个值，同时因为这个点很“稳定”，于是它不再往外跑，从而得到了一个解。</p>
<p>那时候的理解很粗糙，没能真正弄懂极限与无穷。但是从利用这个工具解题的过程中还是获得了一点认知：谁掌握了不动点，谁就掌握了整个复杂过程的解。</p>
<h2 id="方程例子"><a class="header" href="#方程例子">方程例子</a></h2>
<p>上面提到的 <code>blog</code> 里，作者引用的是函数定义上的不动点，即若 <code>f(x)=x</code>，则 <code>x</code> 是 <code>f</code> 的一个不动点。但我觉得数列的例子可能更像一个算法，于是多写了几笔。</p>
<p>言归正传。先从阶乘的例子来看 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 组合子怎么用。<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 组合子有这样的性质：</p>
<pre><code class="language-scheme">Y f = f Y f
</code></pre>
<p>也就是说 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 组合子是这样一个高阶函数：对于任意函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> 都是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的一个不动点</p>
<pre><code class="language-scheme">f (Y f) = (Y f) ; 函数作用是右结合的
</code></pre>
<p>定义对于阶乘函数 <code>fact</code>，定义一个 <code>mk-fact</code>:</p>
<pre><code class="language-scheme">(define (mk-fact fact')
  (lambda (n)
    (cond
      ((= n 1) 1)
      (else (* n (fact' (sub1 n)))))))
</code></pre>
<p>我擦，看起来好麻烦，我换个随意点的写法：</p>
<pre><code class="language-scheme">mk-fact fact' =
  if n = 1  =&gt; 1
  else      =&gt; n * (fact' (n-1)) ; 意思到了就行
</code></pre>
<p>然后直接将 <code>mk-fact</code> 给 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 组合子：</p>
<pre><code class="language-scheme">Y mk-fact = mk-fact (Y mk-fact)
</code></pre>
<p>接着传递 <code>n</code> 的时候，神奇的事情发生了:</p>
<pre><code class="language-scheme">(Y mk-fact) n 

-&gt;
(mk-fact (Y mk-fact)) n

-&gt;
if n = 1  =&gt; 1
else      =&gt; n * ((Y mk-fact) (n-1))
</code></pre>
<p>如果记 <code>fact = Y mk-fact</code>，则：</p>
<pre><code class="language-scheme">fact n =
  if n = 1  =&gt; 1
  else      =&gt; n * (fact (n-1))
</code></pre>
<p>就此得到了阶乘函数 <code>fact</code> 家人们</p>
<h2 id="y-combinator"><a class="header" href="#y-combinator">Y-combinator</a></h2>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span></span></span></span></span></p>
<p>这就是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 组合子</p>
<p>随便带入一个 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.5em;vertical-align:-3.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4em;"><span style="top:-6.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span><span style="top:-0.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">→</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4em;"><span style="top:-6.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">xx</span><span class="mclose">)</span></span></span><span style="top:-0.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">...</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">which is exactly </span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>在 <code>apply</code> 一个具体 <code>f</code> 之后，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 组合子变成了类似 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span> 组合子 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">xx</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">xx</span><span class="mclose">)</span></span></span></span> 的东西</p>
<p>此式永远能继续规约，不能规约到一个 <em>normal form</em>，因而说它是发散的（<em>diverge</em>)</p>
<p>如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 作用于自身，直接代入即有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">YY</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">YYY</span></span></span></span></p>
<h2 id="回过头来"><a class="header" href="#回过头来">回过头来</a></h2>
<p>我们总结一下寻找 <code>fact</code> 的过程：</p>
<p>首先，先把 <code>fact</code> 写出来</p>
<pre><code class="language-scheme">fact = lambda n.
  if n = 1 =&gt; 1
  else =&gt; n * (fact (n-1))
</code></pre>
<p>抽象一下，就是写一个函数体里有 <code>fact</code> 递归调用的函数</p>
<pre><code class="language-scheme">fact = ... fact ...     (1)
</code></pre>
<p>然后我们假设 <code>fact</code> 是某个函数 <code>g</code> 的不动点，即 <code>g fact = fact</code></p>
<p>于是 <code>fact = g fact</code>          (2)</p>
<p>于是 <code>g fact = ... fact ...</code>  (3)，将 (2) 代回 (1) 即得</p>
<p>现在又已知 <code>Y</code> 组合子能求出任意函数的不动点，<code>Y g = g Y g</code>  (4)</p>
<p>于是设 <code>Y g = h</code>，则 <code>g h = h</code>          (5)，带入 (4) 即得</p>
<p>于是 <code>g h = ... h ...</code>    (6)，将 <code>h</code> 作为 <code>fact</code> 代入 (3) 即得</p>
<p>于是 <code>h = ... h ...</code>    将 (5) 代回 (6)</p>
<p>于是解出了阶乘函数（递归函数）<code>h</code></p>
<p>简直是魔术</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h1>
<p>算法精深，不可不学</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="minimum-cut-maximum-flow"><a class="header" href="#minimum-cut-maximum-flow">minimum cut maximum flow</a></h1>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1Q7411R7ie/">jyy老师的图解画的真好</a></p>
</blockquote>
<h2 id="罗列定义"><a class="header" href="#罗列定义">罗列定义</a></h2>
<h3 id="网络流"><a class="header" href="#网络流">网络流</a></h3>
<p>a <em><strong>flow network</strong></em> is a directed graph <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> without multiple arcs, where each edge has a non-negative <em><strong>capacity</strong></em> function <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> and each edge receives a flow.</p>
<p>if 2 nodes are distinguished -- one as the <em><strong>source</strong></em> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>, and the other as the <em><strong>sink</strong></em> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>, then <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> is called a network flow.</p>
<h3 id="流"><a class="header" href="#流">流</a></h3>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 表示从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的流。其应该满足</p>
<ol>
<li><em>Skew symmetric constraint</em>. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>，符号表示方向。这说明以邻接矩阵表示该图，则该矩阵斜对称</li>
<li><em>Capacity constraint</em>. An arc's flow cannot exceed its capacity. that is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>以上两条定义了 <em><strong>pseudo-flow</strong></em>（不知道中文叫什么，伪流吗？）</p>
<p>再加上第三条约束则定义了 <em><strong>feasible flow</strong></em>, or just a <em><strong>flow</strong></em>:</p>
<ol start="3">
<li><em>Flow conservation constraint</em>, 流量守恒，除了 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span></span></span></span> 之外，其余节点都应满足输入等于输出</li>
</ol>
<h3 id="割"><a class="header" href="#割">割</a></h3>
<p>a <em><strong>Cut</strong></em> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> is the set <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">}</span></span></span></span></p>
<p>也就是割只关心从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 的边，反方向的边是不关注的。</p>
<p>the <em><strong>capacity</strong></em> of an <em>s-t cut</em> is defined as the sum of the capacity of each edge in the cut-set.</p>
<h3 id="残量网络"><a class="header" href="#残量网络">残量网络</a></h3>
<p>添加一个流之后网络剩下的容量视为一个新网络. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p>
<h3 id="增广路径"><a class="header" href="#增广路径">增广路径</a></h3>
<p>即找一条从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的路径。</p>
<p>注意流函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 可以为负数，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 说明 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span> 的约束中可以得到 <span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>这描述了 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 的合法范围，这个流可以看作在容量为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的管道中流动</p>
<p>每一条新的流量为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的增广路径 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 都不过是在 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 上每一条边加上一点流量 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。只要 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，这条路径就是合法的。</p>
<h2 id="ford-fulkerson-增广"><a class="header" href="#ford-fulkerson-增广">Ford-Fulkerson 增广</a></h2>
<p>我记得之前看的资料都把这个算法描述为增广的同时添加一条反向边</p>
<img src = "./img/max_flow1.svg" width="45%">
<img src = "./img/max_flow2.svg" width="45%">
<img src = "./img/max_flow3.svg" width="45%">
<img src = "./img/max_flow4.svg" width="45%">
<img src = "./img/max_flow5.svg" width="45%">
<p>jyy 老师的讲解中增加了一个图解：</p>
<img src = "./img/ford-fulkerson1.svg">
<img src = "./img/ford-fulkerson2.svg">
<p>如果把流经一个割两侧的流量之和称为这个割的流量，那么对每一个割来说，每一次增广都一定会增大这个割的流量</p>
<ul>
<li>
<p>问: 一个网络流的任意的割都有相同流量吗？</p>
</li>
<li>
<p>答: 是的。这是显然的，因为一个割把网络流图分割为两部分，而所有从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发的流一定会流到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，因此任意的割的流量都是相等的</p>
</li>
</ul>
<p>虽然割的流量都是相等的，但是割的容量不一定是相等的，它取决于这个割有哪些边</p>
<p>每次增广后，都考虑残差网络的割</p>
<ul>
<li>问: 若一个网络所有割的容量都大于 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则一定可以增广吗？</li>
<li>答: 是的。这个过程很好想象，画图如下：</li>
</ul>
<img src = "./img/augment_cut_capacity.svg">
<p>这个过程中有一个小细节：每一次连接割中两个点 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 并不总是上一次连接进去的点</p>
<p>然而，可以归纳地保证，每一次新连进去的点 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，必有一条从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的增广路径</p>
<p>因而每一次新取的割中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 里的每一个点都能从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发走到</p>
<p>因此，在增广过程的最后连接 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，这保证了有一条从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的路径</p>
<h2 id="最大流最小割定理"><a class="header" href="#最大流最小割定理">最大流最小割定理</a></h2>
<p>上面说明了若一个网络所有割的容量都大于 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则一定可以增广</p>
<p>因此，通过不断的增广，最终会使得残差网络中的所有割当中，至少有一个割，容量为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<p>显然，按此割来分割原网络流：</p>
<img src = "./img/a_cut.svg">
<p>不可能有更大的流了，因而得到了最大流</p>
<p>同时，显然不可能有比它容量更小的割</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>这么看下来好像也没有特别难以理解的地方，可能还是没有做题，检验不出来</p>
<p>如果能很自然地接受负数流，进而理解增广路径的过程，那么接下来就一路平坦了</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="tarjan"><a class="header" href="#tarjan">tarjan</a></h1>
<p>理解 tarjan 和缩点</p>
<img src="./img/tarjan.svg">
<h2 id="tarjan-求强连通分量"><a class="header" href="#tarjan-求强连通分量">tarjan 求强连通分量</a></h2>
<p>理解这个过程的关键在于以 dfs 搜索树和搜索栈的视角来看待图遍历</p>
<img src="./img/tarjan_tree.svg">
<p>众所周知 dfs 一个图的过程可以看作一棵树</p>
<hr />
<ul>
<li>问：如果树的一个节点 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 可以延申一条边到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 的祖先，说明什么</li>
<li>答：说明 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 位于同一个强连通分量</li>
</ul>
<hr />
<ul>
<li>问：如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 不是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 的祖先，说明什么</li>
<li>答：看情况，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 能连 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 说明 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 在同一个强连通分量，而 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 能连 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 什么也说明不了</li>
</ul>
<hr />
<ul>
<li>问：是什么造成了这种差异</li>
<li>答：因为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 与 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 强连通，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 的祖先</li>
</ul>
<hr />
<ul>
<li>问：强连通说明什么</li>
<li>答：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 强连通，从某种意义上可以将 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 与 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 看作同一个点</li>
</ul>
<hr />
<ul>
<li>问：然后呢</li>
<li>答：所以 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 实际上可以看作就是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 的祖先</li>
</ul>
<hr />
<ul>
<li>问：有个问题，如果 dfs 的过程中，先发现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 能连接 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>，然后才发现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 能连 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，可怎么办</li>
<li>答：这种情况不会出现</li>
</ul>
<hr />
<ul>
<li>问：为什么</li>
<li>答：因为如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 在同一个强连通分量，那么当 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 还在搜索栈里的时候，一定有办法碰到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></li>
</ul>
<hr />
<ul>
<li>问：也就是说不可能出现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 没发现 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 跟自己在同一个强连通分量里，反而要通过后续的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 来间接发现的情况</li>
<li>答：对</li>
</ul>
<hr />
<ul>
<li>问：所以当看到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 能碰到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 的时候直接无视就好了</li>
<li>答：对。因为如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 能碰到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，但 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 又不在 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 的子树里，这说明 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 已经遍历完了。
这也说明 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 不在 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 的子树里。所以假如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 能与 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 强连通，那么唯一的可能是他们都至少与 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 强连通，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 是他们的公共祖先</li>
</ul>
<hr />
<ul>
<li>问：所以即使 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 强连通，他们也有可能不在对方的子树里</li>
<li>答：对。可以想象这样一种情况：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 强连通，但他们之间仅仅由一个节点 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 连接，没有其他互相到达的路径。如果此时 dfs 不巧以 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 作为二者的祖先来遍历，那么由于每个节点都只在 dfs 中出现一次，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 不能通过 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 来互相抵达</li>
</ul>
<hr />
<ul>
<li>问：是搜索剪枝导致它这样的</li>
<li>答：是的</li>
</ul>
<hr />
<ul>
<li>问：那假如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 强连通，则他们一定都与 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 强连通吗？我的意思是，他们有没有可能通过其他节点来连接起来</li>
<li>答：可以分情况解答：
<ol>
<li>若 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 和他们其他的公共祖先，比如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 强连通，那么 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 一定和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 也强连通，这很显然</li>
<li>若 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 通过 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 强连通起来，那么在 dfs 的过程里，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 应该是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 的公共祖先，这与现在的情况矛盾</li>
</ol>
</li>
</ul>
<hr />
<ul>
<li>问：我再想想 #沉淀</li>
<li>答：如果从结果倒推，当 dfs 接触到一坨强连通分量时，碰到的第一个节点 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 就应该是该强连通分量里其他所有节点的祖先。这很自然，因为从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 一定能到达其余所有节点</li>
</ul>
<hr />
<img src="./img/tarjan_tree2.svg">
<hr />
<ul>
<li>问：也就是说，从直观上来看，一个强连通分量在 dfs 树上一定也是连通的</li>
<li>答：是的，只要 dfs 搜索树长成了这样，并且 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 不连通，那么就算 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 跟 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span></span></span></span> 连出了花，他们也一定不连通</li>
</ul>
<hr />
<ul>
<li>问：因为如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 连通，那么他们一定都和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 连通。同样如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 连通，则他们要么一方在另一方的子树里，要么有连通的公共祖先</li>
<li>答：对</li>
</ul>
<hr />
<ul>
<li>问：是不是如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 在不同的子树，但他们连通，则他们一定有且仅有唯一的公共祖先</li>
<li>答：并不，比如他们可以和最小公共祖先的父节点也连通</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="fft"><a class="header" href="#fft">fft</a></h1>
<p>理解完了之后试试高精度</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cicd"><a class="header" href="#cicd">CICD</a></h1>
<p>看了半天 <code>github actions</code>，它这个 <code>reusable workflow</code> 是否有些难用。</p>
<p>不同 <code>workflow</code> 之间的环境差异有点难以理解，如果环境不同，如何复用别的过程呢。</p>
<p>先用 <code>actions-rs/install</code> 顶上，以后看看有没有更好的讲解。</p>
<h2 id="好像没用"><a class="header" href="#好像没用">好像没用</a></h2>
<p>这个包在第二次仍然重新编译了，似乎没有按他说的被加入 <code>Github cache</code>，难道这个过程也需要时间吗。</p>
<h2 id="确实出问题了"><a class="header" href="#确实出问题了">确实出问题了</a></h2>
<p>tragic.</p>
<pre><code class="language-console">&gt; Run actions-rs/install@v0.1.2
&gt; Tool cache is explicitly enabled via the Action input
&gt; Downloading from the tool cache
  Newest mdbook-katex version available at crates.io: 0.4.0
  Downloading mdbook-katex signature into /tmp/mdbook-katex.zip.sig
  Warning: Unable to download mdbook-katex == latest from the tool cache: Error: Unexpected HTTP response: 403
&gt; Falling back to the `cargo install` command
</code></pre>
<p>看这 <code>repo</code> 的 <code>issue</code> 里边好像说不会修这个 <code>bug</code>。上次 <code>commit</code> 都是 3 年前了，令人感叹。</p>
<p>还是得每次编译一下，麻。有时间还是自己研究一下 <code>workflow</code></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="english-is-important"><a class="header" href="#english-is-important">English is important</a></h1>
<blockquote>
<p>人们相信，既然皇帝连老奶奶家的水管坏了这种琐事都愿意管，那么更大的事情就更不必说</p>
</blockquote>
<p>新概念是个好教材，我接下来将做完上面的题。</p>
<p>题目多数是造句，填词，改词，作文。这很符合学习过程，先输入再输出</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="多少沾点"><a class="header" href="#多少沾点">多少沾点</a></h1>
<blockquote>
<p>赍百年之寿命，持至贵之重器，委付凡医，恣其所措。</p>
</blockquote>
<p>只能忍痛闭眼，令人感叹。</p>
<p>在这里放一点东偷西摸来，或者自己写的杂文散篇。当然，凡能说出来的，那都不叫心里话。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="attention-please"><a class="header" href="#attention-please">attention please</a></h1>
<h2 id="关于训练"><a class="header" href="#关于训练">关于训练</a></h2>
<ol>
<li>
<p>尽量降低注意力的阈值，不要转向高刺激低成本的活动，比如短视频。</p>
</li>
<li>
<p>进行集中注意力的对抗。有意识地对抗分心，减少屈服的次数。</p>
</li>
</ol>
<h2 id="关于神经兴奋"><a class="header" href="#关于神经兴奋">关于神经兴奋</a></h2>
<p>刚看了个关于<a href="https://www.bilibili.com/video/BV1pm4y1y7N5/?spm_id_from=333.880.my_history.page.click">手冲和健身的视频</a>。虽然是营销号，但感觉说的很有道理。冲完之后确实感觉不想使劲。刚睡一觉起来发现能一个引体向上了。</p>
<p>该少冲还是得少冲。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="h1"><a class="header" href="#h1">H1</a></h1>
<blockquote>
<p>这群在连云港过冬的蛎鹬本来依赖两个因放水而露出底部的鱼塘作为高潮栖息地，但是前段时间鱼塘又开始蓄水，让它们失去了合适的高潮地，潮水上涨时候只能像这样挤在鱼塘边的土质堤坝上，休息环境更差而且容易受人惊扰，实在是很可怜</p>
</blockquote>
<h2 id="h2"><a class="header" href="#h2">H2</a></h2>
<h3 id="h3"><a class="header" href="#h3">H3</a></h3>
<ul>
<li>1</li>
</ul>
<ol>
<li>2</li>
</ol>
<h2 id="font"><a class="header" href="#font">font</a></h2>
<p>testing: <code>code</code></p>
<p>testing: <em>italic</em></p>
<p>testing: <strong>bold</strong></p>
<h2 id="mathjax"><a class="header" href="#mathjax">mathjax</a></h2>
<p>\( \int x dx = \frac{x^2}{2} + C \)</p>
<p>\[ \mu = \frac{1}{N} \sum_{i=0} x_i \]</p>
<h2 id="katex"><a class="header" href="#katex">katex</a></h2>
<p>testing: inline formula: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3998em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></p>
<p>testing: block formula: <span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span></p>
<h2 id="code"><a class="header" href="#code">code</a></h2>
<pre><code class="language-cpp">#include __FILE__

template &lt;typename T, class C, int R&gt;
using T = C&lt;R&gt;;

static inline register void mian(){
    auto f = mian();
    int a = (long) (void*) &amp;f;
    f(a);

    return 1;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
